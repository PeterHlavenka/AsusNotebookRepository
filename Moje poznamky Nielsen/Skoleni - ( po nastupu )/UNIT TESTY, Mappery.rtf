{\rtf1\ansi\ansicpg1250\deff0\nouicompat\deflang1029{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset238 Calibri;}{\f2\fnil Calibri;}{\f3\fnil\fcharset0 Segoe UI;}{\f4\fnil Consolas;}{\f5\fnil\fcharset0 Consolas;}{\f6\fnil\fcharset2 Symbol;}}
{\colortbl ;\red255\green0\blue0;\red0\green0\blue0;\red0\green0\blue255;\red43\green145\blue175;\red0\green128\blue0;}
{\*\generator Riched20 10.0.14393}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs28\lang9\par
\tab\cf1\b\fs36 Unit testy\par

\pard\cf0\b0\fs28\tab\cf1\b\fs36\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\cf0\b0\fs28 Nainstalujeme ReSharpera z webu   \f1\fs20\lang1029 [\f2\ltrmark\f0 8/\f2\ltrmark\f0 15/\f2\ltrmark\f0 2017 2:41 PM] Petr Mitrofan:  \cf2\f3\lang1033 zatim stahni a nainstaluj tohle {\cf0\outl{\field{\*\fldinst{HYPERLINK https://www.jetbrains.com/resharper/ }}{\fldrslt{https://www.jetbrains.com/resharper/\ul0\cf0}}}}\f3\fs20  \cf0\f0\fs28\par
{\pntext\f6\'B7\tab}\strike\f1\lang1029 Do Solution zalozime novy projekt , bude se jmenovat WPFUniverse.UnitTests\strike0\par
{\pntext\f6\'B7\tab}\f0\lang1033 Po prechodu na Caliburn to bude projekt : WpfUniverse.Core.Tests  a bude mit reference na assembly, podle toho co testujeme .  (Core , Entity)\f1\lang1029\par
{\pntext\f6\'B7\tab}\strike\f0\lang9 Nastavime reference , aby testovaci projekt videl na vsechny ostatni projekty.\strike0\par
{\pntext\f6\'B7\tab}Stahneme balicek \b NUnit\b0   coz je testovaci framework a balik \b Moq\b0 .  \par
{\pntext\f6\'B7\tab}Pridame tridu PropertiesViewModelFixture.cs\par

\pard\sa200\sl276\slmult1\tab Je to  vlastne testovaci trida ktera nam nahradi v aplikaci PropertiesViewModel aniz by to aplikace poznala.\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Aby se vedelo ze jde o Unit test nad tridu prijde metadata klauzule  :  \cf2\f4\fs19 [\cf4 TestFixture\cf2 ]\cf0\f0\fs28\par
{\pntext\f6\'B7\tab}\cf2\lang1033 A nad nazev testovaci metody   \f4\fs19 [\cf4 Test\cf2 ]\cf0\f0\fs28\lang9\par
{\pntext\f6\'B7\tab}Jelikoz ma skutecna trida PropertiesViewModel nejake zavislosti musime ji tyto zavislosti vytvorit.    \par

\pard\li720\sa200\sl276\slmult1 Na to slouzi prave balicek Moq.\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Ten vytvori falesne instance rozhrani ktere jsou v testovaci tride jako zavislosti        \cf4\f4\fs19 Mock\cf2 <\cf4 IPlanetSelector\cf2 > planetSelectorMock = \cf3 new\cf2  \cf4 Mock\cf2 <\cf4 IPlanetSelector\cf2 >();\cf0\f0\fs28\par

\pard\sa200\sl276\slmult1\par
\tab\b Co testujeme :   \b0 Chceme vedet jestli po kliknuti na checkbox v PropertiesViewModelu , bude pridana do \b SelectedPlanet.Properties \b0 na spravne misto hodnota true do vlastnosti \b IsChecked\b0 .\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Vytvorime si vlastni testovaci data . V tomto pripade potrebujeme kolekci VlastnostDataContractu  a rovnou do ni  nekolik datacontractu vlozime.\par
{\pntext\f6\'B7\tab}Testy se provadi pomoci metod. \par
{\pntext\f6\'B7\tab}Nezapomenout zaregistrovat pripadne eventy ktere ve tride spousti nejakou cinnost:\par

\pard\li2160\sa200\sl276\slmult1\cf2\f4\fs19 viewModel.RegisterToEvent();\par
\cf0\f0\fs28\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Rekneme propertiesManageru , ze chceme vymenit ListOfPossibleVlastnost ze skutecne tridy , za nasi observableCollection.\par

\pard\sa200\sl276\slmult1\tab\tab\tab\cf2\f4\fs22 propertiesManagerMock.Setup(d => d.ListOfAllPossibleVlastnosts).Returns(() => observableCollection);\par
\cf0\f0\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\fs28 Vytvorime instanci PropertiesViewModelu, pricemz ji dame zavislosti na nase falesne MockObjekty.\par

\pard\li2160\sa200\sl276\slmult1\cf4\f4\fs22 PropertiesViewModel\cf2  viewModel = \cf3 new\cf2  \cf4 PropertiesViewModel\cf2 (planetSelectorMock.Object, propertiesManagerMock.Object, planetPropertiesDaoMock.Object);\par
\cf0\f0\fs28\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Vytvorime si PlanetDataContract  selectedPlanet  na kterem budeme testovat.  Po zmene hodnoty IsChecked v nekterem VlastnostDataContractu v nasi falesne kolekci \par

\pard\li2160\sa200\sl276\slmult1\cf2\f4\fs22 observableCollection[0].IsChecked = \cf3 true\cf2 ;\cf0\f0  \par
\par

\pard\li720\sa200\sl276\slmult1\fs28 by se mel datacontract objevit v kolekci  (seznamu vlastnosti)   v selectedPlanet.Propeties.\par
\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Otestujeme pomoci Assert:\par

\pard\sa200\sl276\slmult1\tab\tab\tab     \cf4\f4\fs19 Assert\cf2 .IsNotEmpty(selectedPlanet.Properties);\par
          \f5\lang1033\tab\tab\f4\lang9   \cf4 Assert\cf2 .IsTrue(selectedPlanet.Properties.Count == 1);\par
          \f5\lang1033\tab\tab\f4\lang9   \cf4 Assert\cf2 .AreEqual(selectedPlanet.Properties[0].Id, observableCollection[0].Id);\par
          \f5\lang1033\tab\tab\f4\lang9   \cf4 Assert\cf2 .AreEqual(selectedPlanet.Properties[0].Nazev, observableCollection[0].Nazev);\par
\cf0\f0\fs28\par
\tab  P\f1\'f8\f0\'edkaz assert, \f1  umo\'9e\'f2uje do p\'f8elo\'9een\f0\'e9ho programu za\f1\'f8adit kontrolu, zda je spln\'ecna podm\f0\'ednka uveden\'e1 za kl\'ed\f1\'e8ov\f0\'fdm slovem assert. Pokud tato podm\'ednka spln\f1\'ecna nen\f0\'ed, vyvol\'e1 se v\'fdjimka AssertionError.\par
\tab\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Test spustime pomoci ReSharpu kliknutim vlevo na zelenou tecku jako run nebo debug s breakem\par
{\pntext\f6\'B7\tab}Testujeme pomoci metod  na tridach ktere jsou public. Bud jsou v nejakem interfacu , nebo se daji zavolat pomoci commandu ktery je public.\par
{\pntext\f6\'B7\tab}Aby se spustila metoda v testu musi se taky \cf1  namockovat \cf0\par

\pard\sa200\sl276\slmult1\tab\cf2\f4\fs19 transactionManagerMock.Setup(d => d.CallInsideTransaction(\cf4 It\cf2 .IsAny<\cf4 Action\cf2 >(), \cf4 It\cf2 .IsAny<\cf4 DbManager\cf2 >(),\par
                    \cf4 It\cf2 .IsAny<\cf4 IsolationLevel\cf2 >())).Callback((\cf4 Action\cf2  action, \cf4 DbManager\cf2  db, \cf4 IsolationLevel\cf2  isl) => action.Invoke());\cf0\f0\fs28\par
\tab jinak probehne prazdna medota   ( DoAllChanges mi nejezdilo)\par
\par
\b\tab Kod udrzovat rozdeleny na atomicke casti , prehledny cisty  a pokud mozno blby. \b0\par
\tab\b Testy by meli byt jednoduche a kratke jinak je pravdepodobne , ze je spatne napsana aplikace.\b0\par
\par
\tab\cf1\b\fs36 Mappery a Unit Testy\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\cf0\b0\fs28 Mappery zjednodusi kod v testech . \par
{\pntext\f6\'B7\tab}Udelame slozku v Core\par
{\pntext\f6\'B7\tab}Vytvorili jsme\tab  \cf3\f4\fs22 public\cf2  \cf3 class\cf2  \cf4 GalaxyDataContractMapper\cf2  : \cf4 IMapper\cf2 <\cf4 Galaxie\cf2 , \cf4 GalaxyDataContract\cf2 >\cf0\f0\fs28\par
{\pntext\f6\'B7\tab}Rodicovska trida prebira dva parametry , jeden vstup a jeden vystup\par
{\pntext\f6\'B7\tab}Maper je jednoducha zalezitost ktera prevadi  pomoci metody\b  map \b0  \par

\pard\sa200\sl276\slmult1\tab\cf3\f4\fs19 public\cf2  \cf4 GalaxyDataContract\cf2  Map(\cf4 Galaxie\cf2  obj)\par
        \{\par
            \cf3 return\cf2  \cf3 new\cf2  \cf4\fs22 GalaxyDataContract\cf2\fs19 (obj.Id, obj.Jmeno, obj.PolohaX, obj.PolohaY, obj.PolohaZ);\par
        \}\cf0\f0\fs28\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1 Vraci vystupni objekt.\par
{\pntext\f6\'B7\tab}Testy by mohly byt taky rozdeleny do logickych celku takze pro testy Servisnich akci udelame slozku ServiceActions a do ni tridu s testem.\par
{\pntext\f6\'B7\tab}Tim ze mame mapper , nepotrebujeme v testu delat prevody mezi tridama  a tim je tam mene kodu. \par
{\pntext\f6\'B7\tab}V metode \b TestSetUp()  \b0 se naMockuji instance  a mappery ktere potrebujeme a predame falesne objekty servisni akci.\par
{\pntext\f6\'B7\tab}V metode \b  Execute () \b0  je samotne provadeni operaci a jejich kontrola pomoci \b Assert.\b0   (execute jsem pozdeji zmenil ma tam byt vystizny nazev co se vlastne testuje. Nove se jmenuje \cf4\f4\fs22 SelectAllGalaxiesServiceActionTest\f5\lang1033  )\cf0\f0\fs28\lang9\par
{\pntext\f6\'B7\tab}Metoda m_galaxyDao.\b VerifyAll()     \b0 overuje jestli na falesnem objektu dao opravdu probehla metoda ktera je v definovana v  \cf2\f4\fs19  \f5\lang1033 :\cf0\f0\fs28\lang9\par

\pard\sa200\sl276\slmult1\cf2\f5\fs19\lang1033\tab\cf3\f4\fs22 var\cf2  galaxie = \cf3 new\cf2  \cf4 Galaxie\cf2\{Id = galaxyId\};\cf0\f0\fs28\lang9\par
\cf2\f5\fs19\lang1033\tab\f4\fs22\lang9 m_galaxyDao.Setup(d => d.SelectAll()).Returns(\cf3 new\cf2  \cf4 List\cf2 <\cf4 Galaxie\cf2 > \{galaxie\});\par
\cf0\f0\fs36\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\fs28 Metoda \b .Setup()  \b0  je dostupna po instalaci BLToolkitu.  Tady mi VerifyAll() proveri jestli  probehla spravne a na spravnych prostredcich. Napr. kdyz vymenime objekt galaxie za new Galaxy() tak sice probiha na \tab objektu typu Galaxie  , ale ne na tom , ktery jsme si vytvorili sami a predali mu Id.\par

\pard\sa200\sl276\slmult1\par
\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b NOVA SLOZKA S INSTALLEREM\b0\par
{\pntext\f6\'B7\tab}Jelikoz jsou mappery v Coru potrebujeme tady dalsi slozku Installers . (Prvni je v Shellu )\par
{\pntext\f6\'B7\tab}Trida CoreInstaller, ktera je zde  zaregistruje Mapper do  Windsor containeru.\par
{\pntext\f6\'B7\tab}Ve tride Bootstrapper se musi metoda na tride CoreInstaller zavolat v metode InitializeContainer. \par

\pard\sa200\sl276\slmult1 ///////////////////////////////\par
jediny zachovany test: \par
\cf3\f4\fs19 using\cf2  System.Collections.Generic;\par
\cf3 using\cf2  System.Linq;\par
\cf3 using\cf2  Mediaresearch.Framework.Mapping;\par
\cf3 using\cf2  Moq;\par
\cf3 using\cf2  NUnit.Framework;\par
\cf3 using\cf2  WpfUniverse.Common.Datacontracts;\par
\cf3 using\cf2  WpfUniverse.Common.Requests;\par
\cf3 using\cf2  WpfUniverse.Core.ServiceActions;\par
\cf3 using\cf2  WpfUniverse.Entities;\par
\par
\cf3 namespace\cf2  WpfUniverse.Core.Tests.ServiceActions\par
\{\par
    [TestFixture]\par
    \cf3 public\cf2  \cf3 class\cf2  \cf4 SelectAllGalaxiesServiceActionTest\cf2\par
    \{\par
        \cf3 private\cf2  Mock<IGalaxyDao> m_galaxyDao;\par
        \cf3 private\cf2  Mock<IMapper<Galaxie, GalaxyDataContract>> m_mapper;\par
\par
        \cf3 private\cf2  SelectAllGalaxiesServiceAction SUT;\par
\par
        [SetUp]\par
        \cf3 public\cf2  \cf3 void\cf2  TestSetUp()\par
        \{\par
            m_galaxyDao = \cf3 new\cf2  Mock<IGalaxyDao>();\par
            m_mapper = \cf3 new\cf2  Mock<IMapper<Galaxie, GalaxyDataContract>>();\par
\par
            SUT = \cf3 new\cf2  SelectAllGalaxiesServiceAction(m_galaxyDao.Object, m_mapper.Object);\par
        \}\par
\par
        [Test]\par
        \cf3 public\cf2  \cf3 void\cf2  Execute()\par
        \{\par
            \cf3 const\cf2  \cf3 int\cf2  galaxyId = 5;\par
\par
            \cf3 var\cf2  galaxie = \cf3 new\cf2  Galaxie\{Id = galaxyId\};\par
            m_galaxyDao.Setup(d => d.SelectAll()).Returns(\cf3 new\cf2  List<Galaxie> \{galaxie\});\par
            m_mapper.Setup(d => d.Map(galaxie)).Returns(\cf3 new\cf2  GalaxyDataContract(galaxyId, \cf3 string\cf2 .Empty, 0, 0, 0));\par
\par
            \cf3 var\cf2  response = SUT.Execute(\cf3 new\cf2  SelectAllGalaxiesRequest());\par
\par
            m_galaxyDao.VerifyAll();\par
            m_mapper.VerifyAll();\par
\par
            Assert.IsTrue(response.Galaxies.Any(d=>d.Id == galaxyId));\par
        \}\par
    \}\par
\}\par
\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b\f0\fs28\lang1033 Nejprve se podivame na skutecnou servisni akci. Vidime, ze ma zavislosti na galaxyDao a mapper.\b0\par

\pard\sa200\sl276\slmult1\tab\f4  \cf3 public\cf2  SelectAllGalaxiesServiceAction(IGalaxyDao galaxyDao, IMapper<Galaxie, GalaxyDataContract> mapper)\par
       \f5    \f4  \f5  \f4\{\par
            m_galaxyDao = galaxyDao;\par
            m_mapper = mapper;\par
        \f5     \f4\}\cf0\f0\lang9\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b Tyto dve property si teda namockujeme:\b0\par

\pard\sa200\sl276\slmult1\tab\tab\cf3\f4 private\cf2  Mock<IGalaxyDao> m_galaxyDao;\par
       \f5\lang1033       \f4\lang9  \cf3 private\cf2  Mock<IMapper<Galaxie, GalaxyDataContract>> m_mapper;\par
\cf0\f0\par

\pard\sa200\sl276\slmult1\tab\tab\cf2\f4 [SetUp]\par

\pard\li720\sa200\sl276\slmult1         \cf3 public\cf2  \cf3 void\cf2  TestSetUp()\par
        \{\par
            m_galaxyDao = \cf3 new\cf2  Mock<IGalaxyDao>();\par
            m_mapper = \cf3 new\cf2  Mock<IMapper<Galaxie, GalaxyDataContract>>();\par
\par
\f5\lang1033\tab\tab   \b vytvorime si instanci servisni akce a jako parametry ji dame falesne objekty\b0\f4\lang9\par
            serviceAction = \cf3 new\cf2  SelectAllGalaxiesServiceAction(m_galaxyDao.Object, m_mapper.Object);\par
        \}\cf0\f0\par

\pard{\pntext\f6\'B7\tab}{\*\pn\pnlvlblt\pnf6\pnindent0{\pntxtb\'B7}}\fi-360\li720\sa200\sl276\slmult1\b To byla priprava a ted samotny test:\b0\par

\pard\sa200\sl276\slmult1\b\tab\tab\cf2\b0\f4 [Test]\par
        \cf3 public\cf2  \cf3 void\cf2  SelectAllGalaxiesReturnsSomeGalaxies()\par
        \{\par
            \cf3 const\cf2  \cf3 int\cf2  galaxyId = 5;\par
\par
            \cf3 var\cf2  galaxie = \cf3 new\cf2  Galaxie\{Id = galaxyId\};\par
\par
            \cf5 // specifikujeme co se ma vratit\cf2\par
            m_galaxyDao.Setup(d => d.SelectAll()).Returns(\cf3 new\cf2  List<Galaxie> \{galaxie\});\par
\par
            \cf5 // specifikujeme co se ma vratit\cf2\par
            m_mapper.Setup(d => d.Map(galaxie)).Returns(\cf3 new\cf2  GalaxyDataContract(galaxyId, \cf3 string\cf2 .Empty, 0, 0, 0));\par
\par
            \cf3 var\cf2  response = serviceAction.Execute(\cf3 new\cf2  SelectAllGalaxiesRequest());\par
\par
            \cf5 // overime zda na falesnem objektu opravdu probehla definovana metoda\cf2\par
            m_galaxyDao.VerifyAll();\par
\par
            \cf5 // overime vsechny  ocekavane akce\cf2\par
            m_mapper.VerifyAll();\par
\par
\par
            \cf5 // overime zda response obsahuje Id ktere se rovna zadanemu galaxyId\cf2\par
            Assert.IsTrue(response.Galaxies.Any(d=>d.Id == galaxyId));\par
            Assert.IsTrue(response.Galaxies.Count > 0);\par
        \}\cf0\f0\par

\pard\sa200\sl276\slmult1\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
.\fs22\par
}
 